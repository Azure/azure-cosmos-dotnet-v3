//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// <auto-generated/>

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;

using static Microsoft.Data.Encryption.Resources.Strings;
using static Microsoft.Data.Encryption.Cryptography.DataEncryptionKey;
using static Microsoft.Data.Encryption.Cryptography.EncryptionType;
using static System.Security.Cryptography.CipherMode;
using static System.Security.Cryptography.PaddingMode;

namespace Microsoft.Data.Encryption.Cryptography
{
    /// <summary>
    /// A component for information encryption purposes that uses block ciphers to encrypt and protect data.
    /// This class implements authenticated encryption algorithm with associated data as described in
    /// http://tools.ietf.org/html/draft-mcgrew-aead-aes-cbc-hmac-sha2-05. More specifically this implements
    /// AEAD_AES_256_CBC_HMAC_SHA256 algorithm.
    /// </summary>
    internal class AeadAes256CbcHmac256EncryptionAlgorithm : DataProtector
    {
        /// <summary>
        /// Block size in bytes. AES uses 16 byte blocks.
        /// </summary>
        private const int BlockSizeInBytes = 16;

        /// <summary>
        /// Variable indicating whether this algorithm should work in Deterministic mode or Randomized mode.
        /// For deterministic encryption, we derive an IV from the plaintext data.
        /// For randomized encryption, we generate a cryptographically random IV.
        /// </summary>
        private readonly bool isDeterministicEncryptionType;

        /// <summary>
        /// The Data Encryption Key is an encryption key is used to encrypt data.
        /// </summary>
        private readonly DataEncryptionKey dataEncryptionKey;

        /// <summary>
        /// Byte array with algorithm version used for authentication tag computation.
        /// </summary>
        private static readonly byte[] version = { 1 };


        private static readonly LocalCache<Tuple<DataEncryptionKey, EncryptionType>, AeadAes256CbcHmac256EncryptionAlgorithm> algorithmCache
            = new LocalCache<Tuple<DataEncryptionKey, EncryptionType>, AeadAes256CbcHmac256EncryptionAlgorithm>(maxSizeLimit: 1000);

        /// <summary>
        /// Returns a cached instance of the <see cref="AeadAes256CbcHmac256EncryptionAlgorithm"/> or, if not present, creates a new one.
        /// </summary>
        /// <param name="dataEncryptionKey">The encryption key that is used to encrypt data.</param>
        /// <param name="encryptionType">The type of encryption.</param>
        /// <returns>An <see cref="AeadAes256CbcHmac256EncryptionAlgorithm"/> object.</returns>
        public static AeadAes256CbcHmac256EncryptionAlgorithm GetOrCreate(DataEncryptionKey dataEncryptionKey, EncryptionType encryptionType)
        {
            dataEncryptionKey.ValidateNotNull(nameof(dataEncryptionKey));

            return algorithmCache.GetOrCreate(
                key: Tuple.Create(dataEncryptionKey, encryptionType),
                createItem: () => new AeadAes256CbcHmac256EncryptionAlgorithm(dataEncryptionKey, encryptionType)
            );
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AeadAes256CbcHmac256EncryptionAlgorithm"/> class.
        /// </summary>
        /// <param name="dataEncryptionKey">an encryption key is used to encrypt data</param>
        /// <param name="encryptionType">Determines whether this algorithm should work in Deterministic mode or Randomized mode.</param>
        public AeadAes256CbcHmac256EncryptionAlgorithm(DataEncryptionKey dataEncryptionKey, EncryptionType encryptionType)
        {
            ValidateEncryptionKeySize(dataEncryptionKey.RootKeyBytes.Length);

            this.dataEncryptionKey = dataEncryptionKey;
            isDeterministicEncryptionType = encryptionType == Deterministic;
        }

        /// <summary>
        /// Convert information or data into a code, especially to prevent unauthorized access.
        /// </summary>
        /// <param name="plaintext">The information or data to encrypt.</param>
        /// <returns>The ciphertext information.</returns>
        public override byte[] Encrypt(byte[] plaintext)
        {
            if (plaintext.IsNull())
            {
                return null;
            }

            try
            {
                Aes aes = Aes.Create();
                aes.Key = dataEncryptionKey.EncryptionKeyBytes;
                aes.Mode = CBC;
                aes.Padding = PKCS7;

                if (isDeterministicEncryptionType)
                {
                    aes.IV = GetHMACWithSHA256(plaintext, dataEncryptionKey.IvKeyBytes).Take(BlockSizeInBytes).ToArray();
                }

                ICryptoTransform encryptor = aes.CreateEncryptor();
                MemoryStream memoryStream = new MemoryStream();
                CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
                cryptoStream.Write(plaintext, 0, plaintext.Length);
                cryptoStream.FlushFinalBlock();
                byte[] ciphertext = memoryStream.ToArray();
                byte[] hmac = GenerateAuthenticationTag(aes.IV, ciphertext);

                return version.Concat(hmac).Concat(aes.IV).Concat(ciphertext).ToArray();
            }
            catch (Exception ex)
            {
                string lastTenBytesOfKey = GetBytesAsString(dataEncryptionKey.EncryptionKeyBytes, startFromEnd: true, countOfBytes: 10);
                throw new MicrosoftDataEncryptionException(EncryptionFailed.Format(lastTenBytesOfKey, ex.Message));
            }
        }

        /// <summary>
        /// Convert coded information or data into an intelligible message.
        /// </summary>
        /// <param name="ciphertext">The coded information or data.</param>
        /// <returns>An intelligible message.</returns>
        public override byte[] Decrypt(byte[] ciphertext)
        {
            if (ciphertext.IsNull())
            {
                return null;
            }

            ValidateCiphertextLength(ciphertext, dataEncryptionKey.EncryptionKeyBytes);
            ValidateAlgorithmVersion(ciphertext, dataEncryptionKey.EncryptionKeyBytes);

            const int authenticationTagIndex = 1;
            const int authenticationTagLength = KeySizeInBytes;
            const int initializationVectorIndex = authenticationTagIndex + authenticationTagLength;
            const int initializationVectorLength = BlockSizeInBytes;
            const int encryptedDataIndex = initializationVectorIndex + initializationVectorLength;
            int encryptedDataLength = ciphertext.Length - encryptedDataIndex;

            byte[] authenticationTag = ciphertext.Skip(authenticationTagIndex).Take(authenticationTagLength).ToArray();
            byte[] initializationVector = ciphertext.Skip(initializationVectorIndex).Take(initializationVectorLength).ToArray();
            byte[] encryptedData = ciphertext.Skip(encryptedDataIndex).Take(encryptedDataLength).ToArray();

            ValidateAuthenticationTag(authenticationTag, initializationVector, encryptedData, ciphertext, dataEncryptionKey.EncryptionKeyBytes);

            SymmetricAlgorithm symmetricAlgorithm = Aes.Create();
            symmetricAlgorithm.Key = dataEncryptionKey.EncryptionKeyBytes;
            symmetricAlgorithm.Mode = CBC;
            symmetricAlgorithm.Padding = PKCS7;
            symmetricAlgorithm.IV = initializationVector;

            ICryptoTransform decryptor = symmetricAlgorithm.CreateDecryptor();
            MemoryStream memoryStream = new MemoryStream();
            CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Write);
            cryptoStream.Write(encryptedData, 0, encryptedData.Length);
            cryptoStream.FlushFinalBlock();

            return memoryStream.ToArray();
        }

        private byte[] GenerateAuthenticationTag(byte[] iv, byte[] ciphertext)
        {
            HMACSHA256 hmacSha256 = new HMACSHA256(dataEncryptionKey.MacKeyBytes);
            byte[] versionSize = { sizeof(byte) };
            byte[] buffer = version.Concat(iv).Concat(ciphertext).Concat(versionSize).ToArray();
            byte[] hmac = hmacSha256.ComputeHash(buffer);
            return hmac;
        }

        private static void ValidateCiphertextLength(byte[] ciphertext, byte[] encryptionKey)
        {
            const int minimumCipherTextLength = sizeof(byte) + BlockSizeInBytes + BlockSizeInBytes + KeySizeInBytes;

            if (ciphertext.Length < minimumCipherTextLength)
            {
                ThrowDecryptionFailedException(encryptionKey, ciphertext, InvalidCipherTextSize.Format(ciphertext.Length, minimumCipherTextLength));
            }
        }

        private void ValidateAlgorithmVersion(byte[] ciphertext, byte[] encryptionKey)
        {
            if (ciphertext[0] != version[0])
            {
                ThrowDecryptionFailedException(encryptionKey, ciphertext, InvalidAlgorithmVersion.Format(ciphertext[0].ToString("X2"), version[0].ToString("X2")));
            }
        }

        private void ValidateAuthenticationTag(byte[] authenticationTag, byte[] initializationVector, byte[] encryptedData, byte[] ciphertext, byte[] encryptionKey)
        {
            byte[] computedAuthenticationTag = GenerateAuthenticationTag(initializationVector, encryptedData);

            if (!authenticationTag.SequenceEqual(computedAuthenticationTag))
            {
                ThrowDecryptionFailedException(encryptionKey, ciphertext, InvalidAuthenticationTag);
            }
        }

        private void ValidateEncryptionKeySize(int size)
        {
            if (size != KeySizeInBytes)
            {
                throw new MicrosoftDataEncryptionException(InvalidDataEncryptionKeySize.Format(size));
            }
        }

        private static MicrosoftDataEncryptionException ThrowDecryptionFailedException(byte[] encryptionKey, byte[] ciphertext, string reason)
        {
            string lastTenBytesOfKey = GetBytesAsString(encryptionKey, startFromEnd: true, countOfBytes: 10);
            string firstTenBytesOfCiphertext = GetBytesAsString(ciphertext, startFromEnd: false, countOfBytes: 10);
            throw new MicrosoftDataEncryptionException(DecryptionFailed.Format(lastTenBytesOfKey, firstTenBytesOfCiphertext, reason));
        }

        private static string GetBytesAsString(byte[] buffer, bool startFromEnd, int countOfBytes)
        {
            int count = (buffer.Length > countOfBytes) ? countOfBytes : buffer.Length;
            int startIndex = startFromEnd ? buffer.Length - count : 0;
            return BitConverter.ToString(buffer, startIndex, count);
        }
    }
}
