//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// <auto-generated/>

using System;
using System.Linq;
using System.Text;
using Azure.Core;
using Azure.Security.KeyVault.Keys.Cryptography;
using Microsoft.Data.Encryption.Cryptography;

using static Microsoft.Data.Encryption.Resources.Strings;

namespace Microsoft.Data.Encryption.AzureKeyVaultProvider
{
    /// <summary>
    /// Implementation of key encryption key store provider that allows client applications to access data when a 
    /// key encryption key is stored in Microsoft Azure Key Vault. 
    /// </summary>
    internal class AzureKeyVaultKeyStoreProvider : EncryptionKeyStoreProvider
    {
        #region Properties

        /// <summary>
        /// Name of the Encryption Key Store Provider implemetation
        /// </summary>
        public override string ProviderName { get; } = "AZURE_KEY_VAULT";

        /// <summary>
        /// Key storage and cryptography client
        /// </summary>
        private KeyCryptographer KeyCryptographer { get; set; }

        /// <summary>
        /// Algorithm version
        /// </summary>
        private readonly static byte[] firstVersion = new byte[] { 0x01 };

        private readonly static KeyWrapAlgorithm keyWrapAlgorithm = KeyWrapAlgorithm.RsaOaep;

        /// <summary>
        /// List of Trusted Endpoints
        /// </summary>
        public readonly string[] TrustedEndPoints;

        #endregion

        #region Constructors
        /// <summary>
        /// Constructor that takes an implementation of Token Credential that is capable of providing an OAuth Token.
        /// </summary>
        /// <param name="tokenCredential"></param>
        public AzureKeyVaultKeyStoreProvider(TokenCredential tokenCredential) :
            this(tokenCredential, Constants.AzureKeyVaultPublicDomainNames)
        { }

        /// <summary>
        /// Constructor that takes an implementation of Token Credential that is capable of providing an OAuth Token and a trusted endpoint. 
        /// </summary>
        /// <param name="tokenCredential">Instance of an implementation of Token Credential that is capable of providing an OAuth Token.</param>
        /// <param name="trustedEndPoint">TrustedEndpoint is used to validate the key encryption key path.</param>
        public AzureKeyVaultKeyStoreProvider(TokenCredential tokenCredential, string trustedEndPoint) :
            this(tokenCredential, new[] { trustedEndPoint })
        { }

        /// <summary>
        /// Constructor that takes an instance of an implementation of Token Credential that is capable of providing an OAuth Token 
        /// and an array of trusted endpoints.
        /// </summary>
        /// <param name="tokenCredential">Instance of an implementation of Token Credential that is capable of providing an OAuth Token</param>
        /// <param name="trustedEndPoints">TrustedEndpoints are used to validate the key encryption key path</param>
        public AzureKeyVaultKeyStoreProvider(TokenCredential tokenCredential, string[] trustedEndPoints)
        {
            tokenCredential.ValidateNotNull(nameof(tokenCredential));
            trustedEndPoints.ValidateNotNull(nameof(trustedEndPoints));
            trustedEndPoints.ValidateNotEmpty(nameof(trustedEndPoints));
            trustedEndPoints.ValidateNotNullOrWhitespaceForEach(nameof(trustedEndPoints));

            KeyCryptographer = new KeyCryptographer(tokenCredential);
            TrustedEndPoints = trustedEndPoints;
        }
        #endregion

        #region Public methods

        /// <summary>
        /// Uses an asymmetric key identified by the key path to sign the key encryption key metadata consisting of (keyEncryptionKeyPath, allowEnclaveComputations bit, providerName).
        /// </summary>
        /// <param name="encryptionKeyId">Identifier of an asymmetric key in Azure Key Vault.</param>
        /// <param name="allowEnclaveComputations">Indicates whether the key encryption key supports enclave computations.</param>
        /// <returns>The signature of the key encryption key metadata.</returns>
        public override byte[] Sign(string encryptionKeyId, bool allowEnclaveComputations)
        {
            ValidateNonEmptyAKVPath(encryptionKeyId, isSystemOp: false);

            // Also validates key is of RSA type.
            KeyCryptographer.AddKey(encryptionKeyId);
            byte[] message = CompileKeyEncryptionKeyMetadata(encryptionKeyId, allowEnclaveComputations);
            return KeyCryptographer.SignData(message, encryptionKeyId);
        }

        /// <summary>
        /// Uses an asymmetric key identified by the key path to verify the key encryption key metadata consisting of (keyEncryptionKeyPath, allowEnclaveComputations bit, providerName).
        /// </summary>
        /// <param name="encryptionKeyId">Identifier of an asymmetric key in Azure Key Vault</param>
        /// <param name="allowEnclaveComputations">Indicates whether the key encryption key supports enclave computations.</param>
        /// <param name="signature">The signature of the key encryption key metadata.</param>
        /// <returns>Boolean indicating whether the key encryption key metadata can be verified based on the provided signature.</returns>
        public override bool Verify(string encryptionKeyId, bool allowEnclaveComputations, byte[] signature)
        {
            ValidateNonEmptyAKVPath(encryptionKeyId, isSystemOp: true);

            var key = Tuple.Create(encryptionKeyId, allowEnclaveComputations, signature.ToHexString());
            return GetOrCreateSignatureVerificationResult(key, VerifyKeyEncryptionKeyMetadata);

            bool VerifyKeyEncryptionKeyMetadata()
            {
                // Also validates key is of RSA type.
                KeyCryptographer.AddKey(encryptionKeyId);
                byte[] message = CompileKeyEncryptionKeyMetadata(encryptionKeyId, allowEnclaveComputations);
                return KeyCryptographer.VerifyData(message, signature, encryptionKeyId);
            }
        }

        /// <summary>
        /// This function uses the asymmetric key specified by the key path
        /// and decrypts an encrypted data dencryption key with RSA encryption algorithm.
        /// </summary>
        /// <param name="encryptionKeyId">Identifier of an asymmetric key in Azure Key Vault</param>
        /// <param name="algorithm">The encryption algorithm.</param>
        /// <param name="encryptedKey">The ciphertext key.</param>
        /// <returns>Plain text data encryption key</returns>
        public override byte[] UnwrapKey(string encryptionKeyId, KeyEncryptionKeyAlgorithm algorithm, byte[] encryptedKey)
        {
            // Validate the input parameters
            ValidateNonEmptyAKVPath(encryptionKeyId, isSystemOp: true);
            ValidateEncryptionAlgorithm(algorithm);
            encryptedKey.ValidateNotNull(nameof(encryptedKey));
            encryptedKey.ValidateNotEmpty(nameof(encryptedKey));
            ValidateVersionByte(encryptedKey[0], firstVersion[0]);

            return GetOrCreateDataEncryptionKey(encryptedKey.ToHexString(), DecryptEncryptionKey);

            byte[] DecryptEncryptionKey()
            {
                // Also validates whether the key is RSA one or not and then get the key size
                KeyCryptographer.AddKey(encryptionKeyId);

                int keySizeInBytes = KeyCryptographer.GetKeySize(encryptionKeyId);

                // Get key path length
                int currentIndex = firstVersion.Length;
                ushort keyPathLength = BitConverter.ToUInt16(encryptedKey, currentIndex);
                currentIndex += sizeof(ushort);

                // Get ciphertext length
                ushort cipherTextLength = BitConverter.ToUInt16(encryptedKey, currentIndex);
                currentIndex += sizeof(ushort);

                // Skip KeyPath
                // KeyPath exists only for troubleshooting purposes and doesnt need validation.
                currentIndex += keyPathLength;

                // validate the ciphertext length
                if (cipherTextLength != keySizeInBytes)
                {
                    throw new MicrosoftDataEncryptionException(InvalidCiphertextLengthTemplate.FormatInvariant(cipherTextLength, keySizeInBytes, encryptionKeyId));
                }

                // Validate the signature length
                int signatureLength = encryptedKey.Length - currentIndex - cipherTextLength;
                if (signatureLength != keySizeInBytes)
                {
                    throw new MicrosoftDataEncryptionException(InvalidSignatureLengthTemplate.FormatInvariant(signatureLength, keySizeInBytes, encryptionKeyId));
                }

                // Get ciphertext
                byte[] cipherText = encryptedKey.Skip(currentIndex).Take(cipherTextLength).ToArray();
                currentIndex += cipherTextLength;

                // Get signature
                byte[] signature = encryptedKey.Skip(currentIndex).Take(signatureLength).ToArray();

                // Compute the message to validate the signature
                byte[] message = encryptedKey.Take(encryptedKey.Length - signatureLength).ToArray();

                if (null == message)
                {
                    throw new MicrosoftDataEncryptionException(NullHash);
                }

                if (!KeyCryptographer.VerifyData(message, signature, encryptionKeyId))
                {
                    throw new MicrosoftDataEncryptionException(InvalidSignatureTemplate.FormatInvariant(encryptionKeyId));
                }

                return KeyCryptographer.UnwrapKey(keyWrapAlgorithm, cipherText, encryptionKeyId);
            }
        }

        /// <summary>
        /// This function uses the asymmetric key specified by the key path
        /// and encrypts an unencrypted data encryption key with RSA encryption algorithm.
        /// </summary>
        /// <param name="encryptionKeyId">Identifier of an asymmetric key in Azure Key Vault</param>
        /// <param name="algorithm">The encryption algorithm.</param>
        /// <param name="key">The plaintext key.</param>
        /// <returns>Encrypted data encryption key</returns>
        public override byte[] WrapKey(string encryptionKeyId, KeyEncryptionKeyAlgorithm algorithm, byte[] key)
        {
            // Validate the input parameters
            ValidateNonEmptyAKVPath(encryptionKeyId, isSystemOp: true);
            ValidateEncryptionAlgorithm(algorithm);
            key.ValidateNotNull(nameof(key));
            ValidateDataEncryptionKeyNotEmpty(key);

            // Also validates whether the key is RSA one or not and then get the key size
            KeyCryptographer.AddKey(encryptionKeyId);
            int keySizeInBytes = KeyCryptographer.GetKeySize(encryptionKeyId);

            // Construct the encryptedDataEncryptionKey
            // Format is 
            //          firstVersion + keyPathLength + ciphertextLength + keyPath + ciphertext  + signature

            // Get the Unicode encoded bytes of cultureinvariant lower case keyEncryptionKeyPath
            byte[] keyEncryptionKeyPathBytes = Encoding.Unicode.GetBytes(encryptionKeyId.ToLowerInvariant());
            byte[] keyPathLength = BitConverter.GetBytes((short)keyEncryptionKeyPathBytes.Length);

            // Encrypt the plain text
            byte[] cipherText = KeyCryptographer.WrapKey(keyWrapAlgorithm, key, encryptionKeyId);
            byte[] cipherTextLength = BitConverter.GetBytes((short)cipherText.Length);

            if (cipherText.Length != keySizeInBytes)
            {
                throw new MicrosoftDataEncryptionException(CipherTextLengthMismatch);
            }

            // Compute message
            // SHA-2-256(version + keyPathLength + ciphertextLength + keyPath + ciphertext) 
            byte[] message = firstVersion.Concat(keyPathLength).Concat(cipherTextLength).Concat(keyEncryptionKeyPathBytes).Concat(cipherText).ToArray();

            // Sign the message
            byte[] signature = KeyCryptographer.SignData(message, encryptionKeyId);

            if (signature.Length != keySizeInBytes)
            {
                throw new MicrosoftDataEncryptionException(HashLengthMismatch);
            }

            ValidateSignature(encryptionKeyId, message, signature);

            return message.Concat(signature).ToArray();
        }

        #endregion

        #region Private methods

        private void ValidateDataEncryptionKeyNotEmpty(byte[] encryptionKey)
        {
            if (encryptionKey.Length == 0)
            {
                throw new MicrosoftDataEncryptionException(EmptyDataEncryptionKey);
            }
        }

        /// <summary>
        /// Checks if the Azure Key Vault key path is Empty or Null (and raises exception if they are).
        /// </summary>
        internal void ValidateNonEmptyAKVPath(string keyEncryptionKeyPath, bool isSystemOp)
        {
            // throw appropriate error if keyEncryptionKeyPath is null or empty
            if (string.IsNullOrWhiteSpace(keyEncryptionKeyPath))
            {
                string errorMessage = null == keyEncryptionKeyPath
                                      ? NullAkvPath
                                      : InvalidAkvPathTemplate.FormatInvariant(keyEncryptionKeyPath);

                if (isSystemOp)
                {
                    throw new MicrosoftDataEncryptionException(errorMessage);
                }

                throw new MicrosoftDataEncryptionException(errorMessage);
            }


            if (!Uri.TryCreate(keyEncryptionKeyPath, UriKind.Absolute, out Uri parsedUri) || parsedUri.Segments.Length < 3)
            {
                // Return an error indicating that the AKV url is invalid.
                throw new MicrosoftDataEncryptionException(InvalidAkvUrlTemplate.FormatInvariant(keyEncryptionKeyPath));
            }

            // A valid URI.
            // Check if it is pointing to trusted endpoint.
            foreach (string trustedEndPoint in TrustedEndPoints)
            {
                if (parsedUri.Host.EndsWith(trustedEndPoint, StringComparison.OrdinalIgnoreCase))
                {
                    return;
                }
            }

            // Return an error indicating that the AKV url is invalid.
            throw new MicrosoftDataEncryptionException(InvalidAkvKeyPathTrustedTemplate.FormatInvariant(keyEncryptionKeyPath, string.Join(", ", TrustedEndPoints.ToArray())));
        }

        private void ValidateSignature(string keyEncryptionKeyPath, byte[] message, byte[] signature)
        {
            if (!KeyCryptographer.VerifyData(message, signature, keyEncryptionKeyPath))
            {
                throw new MicrosoftDataEncryptionException(InvalidSignature);
            }
        }

        private byte[] CompileKeyEncryptionKeyMetadata(string keyEncryptionKeyPath, bool allowEnclaveComputations)
        {
            string keyEncryptionKeyMetadata = ProviderName + keyEncryptionKeyPath + allowEnclaveComputations;
            return Encoding.Unicode.GetBytes(keyEncryptionKeyMetadata.ToLowerInvariant());
        }


        internal static void ValidateEncryptionAlgorithm(KeyEncryptionKeyAlgorithm encryptionAlgorithm)
        {
            if (encryptionAlgorithm != KeyEncryptionKeyAlgorithm.RSA_OAEP)
            {
                throw new MicrosoftDataEncryptionException(InvalidKeyAlgorithm.FormatInvariant(encryptionAlgorithm, KeyEncryptionKeyAlgorithm.RSA_OAEP.ToString()));
            }
        }

        internal static void ValidateVersionByte(byte encryptedByte, byte firstVersionByte)
        {
            // Validate and decrypt the EncryptedDataEncryptionKey
            // Format is 
            //           version + keyPathLength + ciphertextLength + keyPath + ciphertext +  signature
            //
            // keyPath is present in the encrypted data encryption key for identifying the original source of the asymmetric key pair and 
            // we will not validate it against the data contained in the KEK metadata (keyEncryptionKeyPath).

            // Validate the version byte
            if (encryptedByte != firstVersionByte)
            {
                throw new MicrosoftDataEncryptionException(InvalidAlgorithmVersionTemplate.FormatInvariant(encryptedByte.ToString(@"X2"), firstVersionByte.ToString("X2")));
            }
        }

        #endregion
    }
}