//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

namespace Microsoft.Azure.Cosmos.Tests
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Reflection;
    using System.Text.RegularExpressions;
    using Microsoft.Azure.Cosmos.Tracing;

    /// <summary>
    /// It is a custom listener for Activities and Event. It is used to validate the Activities generated by cosmosDb SDK.
    /// </summary>
    internal class TestListener : IObserver<KeyValuePair<string, object>> // Override IObserver to capture Activity events
    {
        private readonly TestEventListener eventListener;

        private ConcurrentBag<ProducedDiagnosticScope> Scopes { get; } = new();
        
        public static ConcurrentBag<Activity> CollectedActivities { private set; get; } = new();

        public TestListener(string eventName)
        {
            this.eventListener = new TestEventListener(eventName);
        }

        /// <summary>
        /// IObserver Override
        /// </summary>
        public void OnCompleted()
        {
            Console.WriteLine("OnCompleted");
            // Unimplemented Method
        }

        /// <summary>
        /// IObserver Override
        /// </summary>
        public void OnError(Exception error)
        {
            Console.WriteLine("OnError => " + error);
            // Unimplemented Method
        }

        /// <summary>
        /// IObserver Override
        /// </summary>
        public void OnNext(KeyValuePair<string, object> value)
        {
            Console.WriteLine($"OnNext: {value.Key} {value.Value}");
            lock (this.Scopes)
            {
                string startSuffix = ".Start";
                string stopSuffix = ".Stop";
                string exceptionSuffix = ".Exception";
                
                if (value.Key.EndsWith(startSuffix) && Activity.Current.IsAllDataRequested)
                {
                    string name = value.Key[..^startSuffix.Length];
                    PropertyInfo propertyInfo = value.Value.GetType().GetTypeInfo().GetDeclaredProperty("Links");
                    IEnumerable<Activity> links = propertyInfo?.GetValue(value.Value) as IEnumerable<Activity> ?? Array.Empty<Activity>();

                    ProducedDiagnosticScope scope = new ProducedDiagnosticScope()
                    {
                        Name = name,
                        Activity = Activity.Current,
                        Links = links.Select(a => new ProducedLink(a.ParentId, a.TraceStateString)).ToList(),
                        LinkedActivities = links.ToList()
                    };

                    Console.WriteLine($"CustomListener: Adding Scope {name} with kind {Activity.Current.Kind}");
                    this.Scopes.Add(scope);
                }
                else if (value.Key.EndsWith(stopSuffix) && Activity.Current.IsAllDataRequested)
                {
                    string name = value.Key[..^stopSuffix.Length];
                    foreach (ProducedDiagnosticScope producedDiagnosticScope in this.Scopes)
                    {
                        if (producedDiagnosticScope.Activity.Id == Activity.Current.Id)
                        {
                            Console.WriteLine($"CustomListener: Stopping Scope {name} kind -> {Activity.Current.Kind} and scope kind ->  {producedDiagnosticScope.Activity.Kind}");

                            producedDiagnosticScope.IsCompleted = true;

                            AssertActivity.IsValid(producedDiagnosticScope.Activity);

                            TestListener.CollectedActivities.Add(producedDiagnosticScope.Activity);
                            
                            return;
                        }
                    }
                    throw new InvalidOperationException($"Event '{name}' was not started");
                }
                else if (value.Key.EndsWith(exceptionSuffix) && Activity.Current.IsAllDataRequested)
                {
                    string name = value.Key[..^exceptionSuffix.Length];
                    foreach (ProducedDiagnosticScope producedDiagnosticScope in this.Scopes)
                    {
                        if (producedDiagnosticScope.Activity.Id == Activity.Current.Id)
                        {
                            Console.WriteLine($"CustomListener: Exception Scope {name}");
                            
                            if (producedDiagnosticScope.IsCompleted)
                            {
                                throw new InvalidOperationException("Scope should not be stopped when calling Failed");
                            }

                            Console.WriteLine($"CustomListener: Scope has exception {(Exception)value.Value}");
                            producedDiagnosticScope.Exception = (Exception)value.Value;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Dispose Override
        /// </summary>
        /// <exception cref="InvalidOperationException"></exception>
        public void Dispose()
        {
            Console.WriteLine("disposing....");

            this.eventListener.Dispose();
          
            lock (this.Scopes)
            {
                this.ResetAttributes();

                foreach (ProducedDiagnosticScope producedDiagnosticScope in this.Scopes)
                {
                    Activity activity = producedDiagnosticScope.Activity;
                    string operationName = activity.OperationName;
                    // traverse the activities and check for duplicates among ancestors
                    while (activity != null)
                    {
                        if (operationName == activity.Parent?.OperationName)
                        {
                            // Throw this exception lazily on Dispose, rather than when the scope is started, so that we don't trigger a bunch of other
                            // erroneous exceptions relating to scopes not being completed/started that hide the actual issue
                            throw new InvalidOperationException($"A scope has already started for event '{producedDiagnosticScope.Name}'");
                        }

                        activity = activity.Parent;
                    }

                    if (!producedDiagnosticScope.IsCompleted)
                    {
                        throw new InvalidOperationException($"'{producedDiagnosticScope.Name}' scope is not completed");
                    }
                }
            }
        }
        
        public List<string> GetRecordedAttributes() 
        {
            List<string> generatedActivityTagsForBaselineXmls = new();
            List<Activity> collectedActivities = new List<Activity>(TestListener.CollectedActivities);

            collectedActivities.OrderBy(act => act.OperationName);
            
            foreach (Activity activity in collectedActivities)
            {
                generatedActivityTagsForBaselineXmls.Add(TagGeneratorUtil.GenerateTagForBaselineTest(activity));
            }
            
            List<string> outputList = new List<string>();
            if(generatedActivityTagsForBaselineXmls != null && generatedActivityTagsForBaselineXmls.Count > 0)
            {
                outputList.AddRange(generatedActivityTagsForBaselineXmls);

            }
            if (this.eventListener.CollectedEvents != null && this.eventListener.CollectedEvents.Count > 0)
            {
                outputList.AddRange(this.eventListener.CollectedEvents);
            }

            return outputList;
        }

        public void ResetAttributes()
        {
            this.eventListener.CollectedEvents = new();
            
            TestListener.CollectedActivities = new();
        }
    }
}
