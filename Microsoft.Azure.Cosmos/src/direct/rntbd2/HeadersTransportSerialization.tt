<#@ template language="C#" hostspecific="true" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\Rntbd\RntbdConstantsDefinition.ttinclude"#><##>
<#@ include file="..\Rntbd\RntbdConstantsResponseTokens.ttinclude"#><##>
<#@ output extension=".cs" #>
<#
Dictionary<string, string> tokenNameOverride = new Dictionary<string, string>()
{
    {"LastStateChangeDateTime", "LastStateChangeUtc"},
    {"ContinuationToken", "Continuation"},
    {"RetryAfterMilliseconds", "RetryAfterInMilliseconds"},
    {"StorageMaxResoureQuota", "MaxResourceQuota"},
    {"StorageResourceQuotaUsage", "CurrentResourceQuotaUsage"},
    {"CollectionUpdateProgress", "CollectionIndexTransformationProgress"},
    {"CollectionLazyIndexProgress", "CollectionLazyIndexingProgress"},
    {"ServerDateTimeUtc", "XDate"},
    {"UnflushedMergeLogEntryCount", "UnflushedMergLogEntryCount"},
    {"ResourceName", "ResourceId"},
    {"BYOKEncryptionProgress", "ByokEncryptionProgress"},
    {"ReindexerProgress", "ReIndexerProgress"},
    {"OfferRestorePending", "IsOfferRestorePending"}
};
#>
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

// THIS IS AN AUTOGENERATED FILE. ALL UPDATES SHOULD BE DONE VIA HeadersTransportSerialization.tt
namespace Microsoft.Azure.Documents.Rntbd
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
#if COSMOSCLIENT
    using Microsoft.Azure.Cosmos.Rntbd;
#endif
    using Microsoft.Azure.Documents.Collections;
    using static Microsoft.Azure.Documents.RntbdConstants;

    /// <summary>
    /// THIS IS AN AUTOGENERATED FILE. ALL UPDATES SHOULD BE DONE VIA RntbdConstants.tt
    /// This allows the RntbdTokenStreams to be correctly ordered and optimized.
    /// If you need to add a new RntbdToken to any of the existing types, do it on the RntbdConstants.tt file
    /// </summary>
    internal static class HeadersTransportSerialization
    {
        public static StoreResponseNameValueCollection BuildStoreResponseNameValueCollection(
            Guid activityId,
            string serverVersion,
            ref BytesDeserializer rntbdHeaderReader)
        {
            StoreResponseNameValueCollection responseHeaders = new()
            {
                ActivityId = activityId.ToString(),
                ServerVersion = serverVersion
            };

            while(rntbdHeaderReader.Position < rntbdHeaderReader.Length)
            {
                ResponseIdentifiers identifier = (ResponseIdentifiers)rntbdHeaderReader.ReadUInt16();
                switch (identifier)
                {
<# foreach(RntbdTokenDefinition token in responseTokens) { #>
<#     if (token.Name == "PayloadPresent") continue; #>
<#     string responseHeadersFieldName = tokenNameOverride.ContainsKey(token.Name) ? tokenNameOverride[token.Name] : token.Name; #>
                    case ResponseIdentifiers.<#= token.Name #>:
                    {
    <# if (token.Name == "RequestCharge") {#>
                        RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
                        Debug.Assert(type == RntbdTokenTypes.Double);
                        double value = rntbdHeaderReader.ReadDouble();
                        responseHeaders.RequestCharge = string.Format(CultureInfo.InvariantCulture, "{0:0.##}", value);
    <#} else if (token.Name == "IndexingDirective") {#>
                        RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
                        Debug.Assert(type == RntbdTokenTypes.Byte);
                        byte value = rntbdHeaderReader.ReadByte();
                        string indexingDirective = value switch
                        {
                            (byte)RntbdConstants.RntbdIndexingDirective.Default => IndexingDirectiveStrings.Default,
                            (byte)RntbdConstants.RntbdIndexingDirective.Exclude => IndexingDirectiveStrings.Exclude,
                            (byte)RntbdConstants.RntbdIndexingDirective.Include => IndexingDirectiveStrings.Include,
                            _ => throw new Exception(),
                        };
                        responseHeaders.IndexingDirective = indexingDirective;
    <#} else if (token.TokenType == "RntbdTokenTypes.UShort") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadUShortHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.ULong") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadUIntHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.ULongLong") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadULongHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.Long") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadIntHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.LongLong") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadLongHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.Double") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadDoubleHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.Guid") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadGuidHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.String") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadStringHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.SmallString") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadSmallStringHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.Byte" && (token.Name == "RequestValidationFailure" || token.Name == "IsRUPerMinuteUsed")) {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadIntBoolHeader(ref rntbdHeaderReader);
    <#} else if (token.TokenType == "RntbdTokenTypes.Byte") {#>
                        responseHeaders.<#= responseHeadersFieldName #> = HeadersTransportSerialization.ReadBoolHeader(ref rntbdHeaderReader);
    <#} else { throw new Exception("Unsupported TokenTypr for response header"); } #>
                        break;
                    }

<# } #>
                    default:
                        {
                            // We have to read all headers if those are in the middle of the payload
                            // For example ReadsPerformed, WritesPerformed,QueriesPerformed, IndexTermsGenerated and ScriptsExecuted 
                            HeadersTransportSerialization.AdvanceByRntbdHeader(ref rntbdHeaderReader, identifier);
                            break;
                        }
                }
            }

            return responseHeaders;
        }

        /// <summary>
        /// Reads PayloadPresent RNTBD header to tell if payload is present. Resets the Position back on <see cref="BytesDeserializer"/>
        /// if PayloadPresent was not the first header to make sure no other data is lost before the final headers processing
        /// in <see cref="TransportSerialization.MakeStoreResponse(StatusCodes, Guid, Stream, string, BytesDeserializer, out uint?)"/>.
        /// </summary>
        /// <remarks>
        /// TODO: https://msdata.visualstudio.com/CosmosDB/_workitems/edit/2105986 consider initializing 
        /// StoreResponseNameValueCollection on the main "receive" thread and reuse headers processing.
        /// </remarks>
        internal static bool TryParseMandatoryResponseHeaders(ref BytesDeserializer rntbdHeaderReader, out bool payloadPresent, out uint transportRequestId)
        {
            payloadPresent = default;
            transportRequestId = default;

            bool hasPayloadPresent = false;
            bool hasTransportRequestId = false;

            while((!hasPayloadPresent || !hasTransportRequestId) && rntbdHeaderReader.Position < rntbdHeaderReader.Length)
            {
                ResponseIdentifiers identifier = (ResponseIdentifiers)rntbdHeaderReader.ReadUInt16();
                if (identifier == ResponseIdentifiers.PayloadPresent)
                {
                    RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
                    Debug.Assert(type == RntbdTokenTypes.Byte);

                    hasPayloadPresent = true;
                    payloadPresent = rntbdHeaderReader.ReadByte() != 0x0;
                }
                else if (identifier == ResponseIdentifiers.TransportRequestID)
                {
                    RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
                    Debug.Assert(type == RntbdTokenTypes.ULong);

                    hasTransportRequestId = true;
                    transportRequestId = rntbdHeaderReader.ReadUInt32();
                }
                else
                {
                    HeadersTransportSerialization.AdvanceByRntbdHeader(ref rntbdHeaderReader, identifier);
                }
            }
            
            return hasPayloadPresent && hasTransportRequestId;
        }

        /// <summary>
        /// Offsetting <see cref="BytesDeserializer"/> by current header. Used to skip unused RNTBD headers.
        /// </summary>
        private static void AdvanceByRntbdHeader(ref BytesDeserializer rntbdHeaderReader, ResponseIdentifiers identifier)
        {
            RntbdTokenTypes tokenType = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            switch (tokenType)
            {
                case RntbdTokenTypes.Byte:
                    {
                        rntbdHeaderReader.ReadByte();
                        return;
                    }

                case RntbdTokenTypes.UShort:
                    {
                        rntbdHeaderReader.AdvancePositionByUInt16();
                        return;
                    }

                case RntbdTokenTypes.ULong:
                    {
                        rntbdHeaderReader.AdvancePositionByUInt32();
                        return;
                    }

                case RntbdTokenTypes.Long:
                    {
                        rntbdHeaderReader.AdvancePositionByInt32();
                        return;
                    }

                case RntbdTokenTypes.ULongLong:
                    {
                        rntbdHeaderReader.AdvancePositionByUInt64();
                        return;
                    }

                case RntbdTokenTypes.LongLong:
                    {
                        rntbdHeaderReader.AdvancePositionByInt64();
                        return;
                    }

                case RntbdTokenTypes.Float:
                    {
                        rntbdHeaderReader.AdvancePositionBySingle();
                        return;
                    }

                case RntbdTokenTypes.Double:
                    {
                        rntbdHeaderReader.AdvancePositionByDouble();
                        return;
                    }

                case RntbdTokenTypes.Guid:
                    {
                        rntbdHeaderReader.AdvancePositionByGuid();
                        return;
                    }

                case RntbdTokenTypes.SmallBytes:
                case RntbdTokenTypes.SmallString:
                    {
                        byte length = rntbdHeaderReader.ReadByte();
                        rntbdHeaderReader.AdvancePositionByBytes(length);
                        return;
                    }
                case RntbdTokenTypes.Bytes:
                case RntbdTokenTypes.String:
                    {
                        ushort length = rntbdHeaderReader.ReadUInt16();
                        rntbdHeaderReader.AdvancePositionByBytes(length);
                        return;
                    }
                case RntbdTokenTypes.ULongBytes:
                case RntbdTokenTypes.ULongString:
                    {
                        uint length = rntbdHeaderReader.ReadUInt32();
                        rntbdHeaderReader.AdvancePositionByBytes((int)length);
                        return;
                    }
                default:
                    {
                        INameValueCollection validationFailureResponseHeader = new DictionaryNameValueCollection();
                        validationFailureResponseHeader.Add(HttpConstants.HttpHeaders.RequestValidationFailure, "1");
                        throw new InternalServerErrorException($"Unrecognized token type {tokenType} with identifier {identifier} found in RNTBD token stream", validationFailureResponseHeader);
                    }
            }
        }

        private static string ReadStringHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.String);
            ushort length = rntbdHeaderReader.ReadUInt16();
            return BytesSerializer.GetStringFromBytes(rntbdHeaderReader.ReadBytes(length));
        }

        private static string ReadSmallStringHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.SmallString);
            byte length = rntbdHeaderReader.ReadByte();
            return BytesSerializer.GetStringFromBytes(rntbdHeaderReader.ReadBytes(length));
        }

        private static string ReadDoubleHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.Double);
            return rntbdHeaderReader.ReadDouble().ToString(CultureInfo.InvariantCulture);
        }

        private static string ReadIntHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.Long);
            return rntbdHeaderReader.ReadInt32().ToString(CultureInfo.InvariantCulture);
        }

        private static string ReadLongHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.LongLong);
            return rntbdHeaderReader.ReadInt64().ToString(CultureInfo.InvariantCulture);
        }

        private static string ReadIntBoolHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.Byte);
            return rntbdHeaderReader.ReadByte() != 0x0 ? "1" : "0";
        }

        private static string ReadBoolHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.Byte);
            return rntbdHeaderReader.ReadByte() != 0x0 ? "true" : "false";
        }

        private static string ReadGuidHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.Guid);
            return rntbdHeaderReader.ReadGuid().ToString();
        }

        private static string ReadUIntHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.ULong);
            return rntbdHeaderReader.ReadUInt32().ToString();
        }

        private static string ReadUShortHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.UShort);
            return rntbdHeaderReader.ReadUInt16().ToString(CultureInfo.InvariantCulture);
        }

        private static string ReadULongHeader(ref BytesDeserializer rntbdHeaderReader)
        {
            RntbdTokenTypes type = (RntbdTokenTypes)rntbdHeaderReader.ReadByte();
            Debug.Assert(type == RntbdTokenTypes.ULongLong);
            return rntbdHeaderReader.ReadUInt64().ToString();
        }
    }
}
